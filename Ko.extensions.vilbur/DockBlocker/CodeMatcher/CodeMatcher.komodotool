{
  "keyboard_shortcut": "", 
  "name": "CodeMatcher", 
  "language": "JavaScript", 
  "trigger_enabled": 1, 
  "rank": 100, 
  "trigger": "trigger_startup", 
  "value": [
    "if( typeof ko.extensions.vilbur === 'undefined'  )", 
    "\tko.extensions.vilbur = {};", 
    "", 
    "/** Search in code for regexes defined in ko.extensions.vilbur.regex_code", 
    " *  Whole block of code is mathced, if RegEx ends with opening brace e.g.: /function(){/gi", 
    " *", 
    " *  @author Vilbur Lubor Cerny <vilbur.webdesign@gmail.com>", 
    " *", 
    " * @method\tCodeMatcher\tlang( string lang )\tset language for searching", 
    " * @method\tCodeMatcher\tcontent( string content )\tset content where to search matches", 
    " * @method\tCodeMatcher\tsearch( string|[string] key )\tset types of code for searching", 
    " *", 
    " * @method\t{search.key:[{}]}\tget()\tget object of arrays with found matches where key is type of RegEx", 
    " * @method\t[Match]\tgetSorted()\tget array of found matches sorted by position", 
    " * @method\t{position:match}\tgetFlatterned()\tget object of found matches where key is found position", 
    " * @method\t[position]\tgetIndexes()\tget array of found positions", 
    " *", 
    " */", 
    "ko.extensions.vilbur.CodeMatcher = (function()", 
    "{", 
    "\t/** CONSTRUCT", 
    "\t */", 
    "\tfunction CodeMatcher()", 
    "\t{", 
    "\t\t/*------   PROPERTIES PRIVATE   -------------------------------------------------------------------------------------------------*/", 
    "", 
    "\t\tvar Logger\t= ko.extensions.Logger_v3 ? new ko.extensions.Logger_v3(this).clear(false).off(false) : require('ko/console');", 
    "", 
    "\t\tvar regex_definition = new ko.extensions.vilbur.regex_code;", 
    "", 
    "\t\tvar content;\t// content where to search matches", 
    "\t\tvar lang;\t// language of content", 
    "", 
    "\t\tvar regeex_search\t= {};", 
    "\t\tvar search_for\t= [];", 
    "\t\t", 
    "\t\tvar matches\t= {}; // store results", 
    "", 
    "", 
    "\t\t/*------   PUBLIC METHODS   -------------------------------------------------------------------------------------------------*/", 
    "\t\t", 
    "\t\t", 
    "\t\t/** Set searching language of content", 
    "\t\t * @param\tstring\tlang\t", 
    "\t\t */", 
    "\t\tthis.lang = function( _lang )", 
    "\t\t{", 
    "\t\t\tlang = _lang=='Node.js' ? 'JavaScript' : _lang;", 
    "\t\t\treturn this;", 
    "\t\t};", 
    "\t\t/** Set content where to search matches", 
    "\t\t *", 
    "\t\t * @param\tstring\tcontent", 
    "\t\t*/", 
    "\t\tthis.content = function(_content)", 
    "\t\t{", 
    "\t\t\tLogger.info(matches, 'CodeMatcher-input: '+'content');", 
    "\t\t\tcontent = _content;", 
    "\t\t\treturn this;", 
    "\t\t};", 
    "", 
    "\t\t/** search for regExes", 
    "\t\t *", 
    "\t\t * @param string|array dot notated key\\s of regex_definition[language]", 
    "\t\t * \t\tE.G.: 'function' OR ['function.public','function.private']", 
    "\t\t *", 
    "\t\t *\t@return this", 
    "\t\t */", 
    "\t\tthis.search = function(keys)", 
    "\t\t{", 
    "\t\t\tsearch_for = typeof keys !== 'object' ? [keys] : keys;", 
    "", 
    "\t\t\tcheckSetup();", 
    "\t\t\tsetRegExSearch();", 
    "\t\t\tsetMatchesAll();", 
    "", 
    "\t\t\treturn this;", 
    "\t\t};", 
    "", 
    "\t\t/** get found matches", 
    "\t\t *", 
    "\t\t * \t@return {search.key:[{}]} object of arrays with found matches where key is type of RegEx e.g.: {function.private:[Match1, Match2]}", 
    "\t\t */", 
    "\t\tthis.get = function()", 
    "\t\t{", 
    "\t\t\t//Logger.info( matches, 'matches');", 
    "\t\t\treturn matches;", 
    "\t\t};", 
    "", 
    "\t\t/** sort matches by position index", 
    "\t\t *", 
    "\t\t * @return\t{position:match}\tobject of found matches where key is found position", 
    "\t\t */", 
    "\t\tthis.getFlatterned = function()", 
    "\t\t{", 
    "\t\t\tvar flatterned = {};", 
    "", 
    "\t\t\tfor(var match_type in matches)", 
    "\t\t\t\tif (matches.hasOwnProperty(match_type))", 
    "\t\t\t\t\tfor(var m=0; m<matches[match_type].length;m++)", 
    "\t\t\t\t\t\tflatterned[ matches[match_type][m].index ] = matches[match_type][m];", 
    "", 
    "\t\t\t//Logger.info(flatterned, 'flatterned');", 
    "\t\t\treturn flatterned;", 
    "\t\t};", 
    "", 
    "\t\t/** sort matches by position index", 
    "\t\t *", 
    "\t\t * @return\t[Match]\tarray of found matches sorted by position", 
    "\t\t */", 
    "\t\tthis.getSorted = function()", 
    "\t\t{", 
    "\t\t\tvar sorted\t= [];", 
    "\t\t\tvar flatterned\t= this.getFlatterned();", 
    "\t\t\tvar keys_sorted\t= this.getIndexes();", 
    "", 
    "\t\t\tfor(var i=0; i<keys_sorted.length;i++)", 
    "\t\t\t\tsorted.push( flatterned[ keys_sorted[i] ] );", 
    "\t\t\t//Logger.info(sorted, 'sorted');", 
    "\t\t\treturn sorted;", 
    "\t\t};", 
    "\t\t/** getIndexes", 
    "\t\t *", 
    "\t\t * @return\t[position]\tarray of found positions", 
    "\t\t */", 
    "\t\tthis.getIndexes = function()", 
    "\t\t{", 
    "\t\t\treturn Object.keys( this.getFlatterned() );", 
    "\t\t};", 
    "\t\t", 
    "\t\t", 
    "\t\t/*------   PRIVATE METHODS    -------------------------------------------------------------------------------------------------*/", 
    "", 
    "\t\t", 
    "\t\t/** checkSetup for coding", 
    "\t\t */", 
    "\t\tvar checkSetup = function()", 
    "\t\t{", 
    "\t\t\tif( typeof lang === 'undefined' )", 
    "\t\t\t\talert( 'CodeMatcher\\n\\n lang() is not defined' );", 
    "", 
    "\t\t\tif( typeof content === 'undefined' )", 
    "\t\t\t\talert( 'CodeMatcher\\n\\n content() is not defined' );", 
    "", 
    "\t\t};", 
    "", 
    "\t\t/** _getContentAfterCursor", 
    "\t\t * @param string direction 'next|prev' get file content BEFORE or AFTER cursor, OR get all file contents if EMPTY", 
    "\t\t */", 
    "\t\tvar getFileContent = function()", 
    "\t\t{", 
    "\t\t\treturn require(\"ko/editor\").getValue();", 
    "\t\t};", 
    "", 
    "\t\t/** get used Regex objects by options.type", 
    "\t\t *", 
    "\t\t * get key by current Language", 
    "\t\t *", 
    "\t\t */", 
    "\t\tvar setRegExSearch = function()", 
    "\t\t{", 
    "\t\t\tvar regex_by_lang = {};", 
    "", 
    "\t\t\t/** Get RegExes by lang and add globals", 
    "\t\t\t */", 
    "\t\t\tvar setRegexByLang = function()", 
    "\t\t\t{", 
    "\t\t\t\t/** mergeGlobals", 
    "\t\t\t\t */", 
    "\t\t\t\tvar mergeGlobals = function()", 
    "\t\t\t\t{", 
    "\t\t\t\t\tfor(var key_global in regex_definition.global)", 
    "\t\t\t\t\t\tif (regex_definition.global.hasOwnProperty(key_global))", 
    "\t\t\t\t\t\t\tregex_by_lang[key_global] = regex_definition.global[key_global];", 
    "\t\t\t\t};", 
    "", 
    "\t\t\t\tregex_by_lang = regex_definition[lang];", 
    "", 
    "\t\t\t\tif( typeof regex_by_lang === 'undefined' ){", 
    "\t\t\t\t\talert( 'RegExCodeObject for lang:\\n'+lang+'\\nis not defined' );", 
    "\t\t\t\t}", 
    "", 
    "\t\t\t\tmergeGlobals();", 
    "\t\t\t};", 
    "", 
    "\t\t\t/** get object item via dot notation", 
    "\t\t\t */", 
    "\t\t\tfunction _getRegexItemByDotNotation(dotNot)", 
    "\t\t\t{", 
    "\t\t\t\tobj\t= regex_by_lang;", 
    "\t\t\t\tdotNot\t= dotNot.replace(/\\[(\\w+)\\]/g, '.$1'); // convert indexes to properties", 
    "\t\t\t\tdotNot = dotNot.replace(/^\\./, '');           // strip a leading dot", 
    "\t\t\t\tvar arr_keys = dotNot.split('.');", 
    "\t\t\t\tfor (var k = 0, n = arr_keys.length; k < n; ++k) {", 
    "\t\t\t\t\tvar key = arr_keys[k];", 
    "\t\t\t\t\tif (key in obj)", 
    "\t\t\t\t\t\tobj = obj[key];", 
    "\t\t\t\t\telse", 
    "\t\t\t\t\t\treturn;", 
    "\t\t\t\t}", 
    "\t\t\t\treturn obj;", 
    "\t\t\t}", 
    "\t\t\t/**", 
    "\t\t\t */", 
    "\t\t\tvar flattenObject = function(obj)", 
    "\t\t\t{", 
    "\t\t\t\tvar toReturn = {};", 
    "", 
    "\t\t\t\tfor (var i in obj) {", 
    "\t\t\t\t\tif (obj.hasOwnProperty(i))", 
    "\t\t\t\t\t\tif ( typeof obj[i]!=='undefined' && obj[i].constructor.name !== 'RegExp') {", 
    "\t\t\t\t\t\t\tvar flatObject = flattenObject(obj[i]);", 
    "\t\t\t\t\t\t\tfor(var x in flatObject)", 
    "\t\t\t\t\t\t\t\tif (flatObject.hasOwnProperty(x))", 
    "\t\t\t\t\t\t\t\ttoReturn[i + '.' + x] = flatObject[x];", 
    "\t\t\t\t\t\t} else", 
    "\t\t\t\t\t\t\ttoReturn[i] = obj[i];", 
    "\t\t\t\t}", 
    "\t\t\t\treturn toReturn;", 
    "\t\t\t};", 
    "", 
    "\t\t\tsetRegexByLang();", 
    "", 
    "\t\t\tif( search_for.length === 0 )", 
    "\t\t\t\tregeex_search = regex_by_lang;", 
    "\t\t\telse", 
    "\t\t\t\tfor(var s=0; s<search_for.length;s++)", 
    "\t\t\t\t\tregeex_search[search_for[s]] = _getRegexItemByDotNotation(search_for[s]);", 
    "", 
    "\t\t\tregeex_search = flattenObject(regeex_search);", 
    "\t\t\t//Logger.info(regex_by_lang, 'regex_by_lang');", 
    "\t\t\t//Logger.info(regeex_search, 'regeex_search');", 
    "\t\t};", 
    "", 
    "\t\t/** find all matches by given parameters.", 
    "\t\t *", 
    "\t\t * find matches or loop sub object of regex_definition and find multiple types at once", 
    "\t\t *", 
    "\t\t * @param object|RegEx regex is RegEx object or subobject from array regex_definition", 
    "\t\t *", 
    "\t\t * @return null", 
    "\t\t */", 
    "\t\tvar setMatchesAll = function()", 
    "\t\t{", 
    "\t\t\t/** find all matches, loop them and set to match_all object.", 
    "\t\t\t *", 
    "\t\t\t *\t!!! GET REGEX !!! core element, this found each regex", 
    "\t\t\t *", 
    "\t\t\t * @param\tobject\tregex\tis RegExp expression or subobject from array regex_definition", 
    "\t\t\t * @param\tstring\trx_key\tis dot notation key of regex from var regexe E.G: 'function.private'", 
    "\t\t\t */", 
    "\t\t\tfunction _findMatchesForRegex(regex)", 
    "\t\t\t{", 
    "\t\t\t\t/** RegEx match all", 
    "\t\t\t\t *", 
    "\t\t\t\t *\t@param\tstring\tsnippet\tof code for searching", 
    "\t\t\t\t *\t@param\tRegEx\tRegEx\tfor searching", 
    "\t\t\t\t * ", 
    "\t\t\t\t * @return array of all matches", 
    "\t\t\t\t */", 
    "\t\t\t\tvar matchAll = function( snippet, RegEx )", 
    "\t\t\t\t{", 
    "\t\t\t\t\tvar matches\t= [];", 
    "\t\t\t\t\tvar last_match_end\t= 0; // end position of last match", 
    "\t\t\t\t\t//Logger.info(search_key, 'search_key');", 
    "", 
    "\t\t\t\t\tvar cloneRegEx = function(_RegEx)", 
    "\t\t\t\t\t{", 
    "\t\t\t\t\t\treturn new RegExp(_RegEx.source, _RegEx.flags);", 
    "\t\t\t\t\t};", 
    "", 
    "\t\t\t\t\t/** Set extra data to match", 
    "\t\t\t\t\t *  1) set absolute postion of match\t// match.index", 
    "\t\t\t\t\t *  2) set type of regex\t// match.type", 
    "\t\t\t\t\t *  3) set block of code\t// match.block_of_code", 
    "\t\t\t\t\t */", 
    "\t\t\t\t\tvar extendMatchWithData = function(match)", 
    "\t\t\t\t\t{", 
    "\t\t\t\t\t\tvar match_extended\t= Object.assign({}, match);", 
    "", 
    "\t\t\t\t\t\t/** Set position of match like it was matched from full content, not from substring in while loop", 
    "\t\t\t\t\t\t */", 
    "\t\t\t\t\t\tvar setAbsoluteFoundPosition = (function()", 
    "\t\t\t\t\t\t{", 
    "\t\t\t\t\t\t\tmatch_extended.index\t= last_match_end + match.index;", 
    "\t\t\t\t\t\t})();", 
    "\t\t\t\t\t\t", 
    "\t\t\t\t\t\t/** Set type of RegEx", 
    "\t\t\t\t\t\t */", 
    "\t\t\t\t\t\tvar setSearchType = (function()", 
    "\t\t\t\t\t\t{", 
    "\t\t\t\t\t\t\tmatch_extended.type\t= key;", 
    "\t\t\t\t\t\t})();", 
    "\t\t\t\t\t\t", 
    "\t\t\t\t\t\t/** Search for block of code if RegEx ends with opening brace e.g.: /function(){/gi", 
    "\t\t\t\t\t\t *  Found block is saved in match.input ", 
    "\t\t\t\t\t\t */", 
    "\t\t\t\t\t\tvar setBlockOfCodeAsInput = (function()", 
    "\t\t\t\t\t\t{", 
    "\t\t\t\t\t\t\tvar opening_brace_match = /[{\\(\\[]$/.exec(RegEx.source);", 
    "\t\t\t\t\t\t\t", 
    "\t\t\t\t\t\t\tif( ! opening_brace_match )", 
    "\t\t\t\t\t\t\t\treturn;", 
    "\t\t\t\t\t\t\t", 
    "\t\t\t\t\t\t\tvar block_end\t= 0;", 
    "\t\t\t\t\t\t\tvar closing_braces\t= {'{':'}', '(':')', '[':']'};", 
    "\t\t\t\t\t\t\tvar opening_brace\t= opening_brace_match.pop();", 
    "\t\t\t\t\t\t\tvar closing_brace\t= closing_braces[opening_brace];\t\t\t\t\t\t", 
    "\t\t\t\t\t\t\tvar RegEx_brace\t= new RegExp('[\\\\' +opening_brace+'\\\\'+closing_brace+ ']');", 
    "\t\t\t\t\t\t\t\t\t\t\t\t\t", 
    "\t\t\t\t\t\t\t/** Search for block of code if RegEx ends with opening brace e.g.: /function(){/gi", 
    "\t\t\t\t\t\t\t*/", 
    "\t\t\t\t\t\t\tvar searchMatchingBrace = (function()", 
    "\t\t\t\t\t\t\t{", 
    "\t\t\t\t\t\t\t\t/** counter object e.g.: { '{':1, '}':0 }", 
    "\t\t\t\t\t\t\t\t */", 
    "\t\t\t\t\t\t\t\tvar counter = (function()", 
    "\t\t\t\t\t\t\t\t{", 
    "\t\t\t\t\t\t\t\t\tvar counter_obj = {};", 
    "\t\t\t\t\t\t\t\t\tcounter_obj[opening_brace] = 1;", 
    "\t\t\t\t\t\t\t\t\tcounter_obj[closing_brace] = 0;\t\t\t\t\t\t\t\t\t", 
    "\t\t\t\t\t\t\t\t\treturn counter_obj;", 
    "\t\t\t\t\t\t\t\t})();", 
    "\t\t\t\t\t\t\t\t", 
    "\t\t\t\t\t\t\t\t/* search closing brace", 
    "\t\t\t\t\t\t\t\t * by counting every new opening brace of sub block", 
    "\t\t\t\t\t\t\t\t*/", 
    "\t\t\t\t\t\t\t\twhile(counter[opening_brace]!==counter[closing_brace])", 
    "\t\t\t\t\t\t\t\t{", 
    "\t\t\t\t\t\t\t\t\tvar match_brace\t= cloneRegEx(RegEx_brace).exec(snippet_next);", 
    "\t\t\t\t\t\t\t\t\t", 
    "\t\t\t\t\t\t\t\t\tif( ! match_brace )", 
    "\t\t\t\t\t\t\t\t\t\tbreak;", 
    "\t\t\t\t\t\t\t\t\t", 
    "\t\t\t\t\t\t\t\t\tsnippet_next\t= snippet_next.substring(match_brace.index +1 ); // set input string for next search", 
    "\t\t\t\t\t\t\t\t\tblock_end\t+= match_brace.index +1;", 
    "\t\t\t\t\t\t\t\t\t", 
    "\t\t\t\t\t\t\t\t\tcounter[match_brace.pop()]++;\t\t\t\t\t\t\t\t", 
    "\t\t\t\t\t\t\t\t}", 
    "\t\t\t\t\t\t\t", 
    "\t\t\t\t\t\t\t\tmatch_extended.block_of_code\t= match[0] + snippet.substring(0, block_end);", 
    "\t\t\t\t\t\t\t})();", 
    "\t\t\t\t\t\t})();", 
    "", 
    "\t\t\t\t\t\treturn match_extended;", 
    "\t\t\t\t\t};", 
    "\t\t\t\t\t/** setLastMatchEnd", 
    "\t\t\t\t\t */", 
    "\t\t\t\t\tvar setLastMatchEnd = function()", 
    "\t\t\t\t\t{", 
    "\t\t\t\t\t\tlast_match_end\t+= match.index + match[0].length;", 
    "\t\t\t\t\t}; ", 
    "\t\t\t\t\t", 
    "\t\t\t\t\t/* Loop content and seach for all matches", 
    "\t\t\t\t\t */", 
    "\t\t\t\t\tif( typeof RegEx !== 'undefined' )", 
    "\t\t\t\t\t\twhile((match = cloneRegEx(RegEx).exec(snippet)) !== null)", 
    "\t\t\t\t\t\t{", 
    "\t\t\t\t\t\t\tsetLastMatchEnd();", 
    "", 
    "\t\t\t\t\t\t\tvar snippet_next\t= snippet.substring(match.index + match[0].length ); // set input string for next search", 
    "\t\t\t\t\t\t\tsnippet\t= snippet_next;", 
    "", 
    "\t\t\t\t\t\t\tmatches.push( extendMatchWithData(match) );", 
    "\t\t\t\t\t\t}", 
    "\t\t\t\t\t//Logger.info(matches, 'matches');", 
    "\t\t\t\t\treturn matches;", 
    "\t\t\t\t};", 
    "", 
    "\t\t\t\treturn matchAll( content, regex );", 
    "\t\t\t}", 
    "\t\t\t/* Loop all regexes and search in content", 
    "\t\t\t */", 
    "\t\t\tfor(var key in regeex_search)", 
    "\t\t\t\tif (regeex_search.hasOwnProperty(key))", 
    "\t\t\t\t\t matches[key] = _findMatchesForRegex( regeex_search[key]) ;", 
    "", 
    "\t\t\tLogger.info(matches, 'CodeMatcher-output: '+'matches');", 
    "", 
    "\t\t};", 
    "", 
    "\t}", 
    "", 
    "   return CodeMatcher;", 
    "})();"
  ], 
  "version": "1.0.12", 
  "async": 1, 
  "type": "macro", 
  "icon": "chrome://fugue/skin/icons/tick.png"
}