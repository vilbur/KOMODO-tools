{
  "keyboard_shortcut": "", 
  "name": "PraseCodeTag", 
  "language": "JavaScript", 
  "trigger_enabled": 1, 
  "rank": 100, 
  "trigger": "trigger_startup", 
  "value": [
    "/** PraseCodeTag", 
    " */", 
    "ko.extensions.PraseCodeTag = (function()", 
    "{", 
    "", 
    "\t//var Logger;", 
    "", 
    "\tfunction PraseCodeTag()", 
    "\t{", 
    "\t\tvar parsed_tag;", 
    "\t\tvar Logger\t= new ko.extensions.Logger_v3('PraseCodeTag.js', false).off(true);", 
    "", 
    "", 
    "\t\tthis.input_string = '';", 
    "", 
    "", 
    "\t\t/** Find and execute method for given tag type", 
    "\t\t *", 
    "\t\t * @param\tstring\ttag_type\ttype of tag for parsing E.G: 'summary|param|return|etc..'", 
    "\t\t *", 
    "\t\t * @return\tarray\tor multiarray of values for tag type E.G: parsed_tag=['string', 'param1', 'fooVal', 'foo description']", 
    "\t\t */", 
    "\t\tthis.parse = function(tag_type){", 
    "\t\t\tLogger.info(tag_type, 'PraseCodeTag.parse()');", 
    "\t\t\tvar method_name\t= 'parse_'+tag_type;", 
    "", 
    "\t\t\tif(typeof this[method_name] !=='undefined')", 
    "\t\t\t\tparsed_tag = this[method_name](); // EXECUTE parse method", 
    "\t\t\telse", 
    "\t\t\t\talert( \"METHOD is not defined:\\nParseTag.\"+method_name+'()' );", 
    "", 
    "\t\t\tLogger.info(parsed_tag, 'PraseCodeTag return - '+tag_type);", 
    "\t\t\treturn parsed_tag;", 
    "\t\t};", 
    "", 
    "\t\t///** setInputString variable", 
    "\t\t// *", 
    "\t\t// * @param\tstring\t_input_string\tpart of code for parsing", 
    "\t\t// */", 
    "\t\t//this.setInputString = function(input_string) {", 
    "\t\t//\tthis.input_string\t= input_string;", 
    "\t\t//};", 
    "\t\t/*\t-------------------------------------------------------------------------------------------------------------\t*/", 
    "\t\t/*\tPARSE METHODS FOR EACH TAG TYPE\t*/", 
    "\t\t/*\t-------------------------------------------------------------------------------------------------------------\t*/", 
    "\t\t/** Parse summary", 
    "\t\t */", 
    "\t\tthis.parse_summary = function()", 
    "\t\t{", 
    "\t\t\t//var\tmatch_variable\t= this.input_string.matchAll_v2(/var\\s*(\\S+)\\s*=/gi, true);", 
    "\t\t\t//if (match_variable)", 
    "\t\t\t\t//return ['@return', 'void', match_variable[1][1]];", 
    "\t\t\t\treturn ['summary', 'Summary from CODE'];", 
    "\t\t};", 
    "", 
    "\t\t/** Parse description", 
    "\t\t */", 
    "\t\tthis.parse_description = function()", 
    "\t\t{", 
    "\t\t\t//var\tmatch_variable\t= this.input_string.matchAll_v2(/var\\s*(\\S+)\\s*=/gi, true);", 
    "\t\t\t//", 
    "\t\t\t//if (match_variable)", 
    "\t\t\t\t//return ['@return', 'void', match_variable[1][1]];", 
    "\t\t\t\treturn ['description', 'Description from CODE'];", 
    "\t\t};", 
    "", 
    "\t\t/** get parameters from brackets", 
    "\t\t *", 
    "\t\t * E.G:", 
    "\t\t * INPUT: '( param1=\"fooString\", param2=true )'", 
    "\t\t * RETURN:[", 
    "\t\t * \t\t['@param', 'string', 'param1', 'fooString'],", 
    "\t\t * \t\t['@param', 'boolean', 'param2', 'true']", 
    "\t\t * ]", 
    "\t\t *", 
    "\t\t * @return array of tag values", 
    "\t\t *", 
    "\t\t */", 
    "\t\tthis.parse_param = function()", 
    "\t\t{", 
    "\t\t\t/*", 
    "\t\t\t *", 
    "\t\t\t */", 
    "\t\t\tvar _splitVariablePairs = function (variable_pairs)", 
    "\t\t\t{", 
    "", 
    "\t\t\t\tvar variables = [];", 
    "\t\t\t\tfor (i = 0; i < variable_pairs.length; i++) {", 
    "", 
    "\t\t\t\t\tif ( variable_pairs[i].match(/^\\s*$/gi) === null ) {", 
    "", 
    "\t\t\t\t\t\tvar variable_split = variable_pairs[i].split(/[:=]/);", 
    "\t\t\t\t\t\t//alert( 'variable_split=\\n'+JSON.stringify( variable_split, null, 2) )", 
    "\t\t\t\t\t\tvariables.push({", 
    "\t\t\t\t\t\t\t\"name\"\t: variable_split[0].split(/\\s+/).pop().trim(),\t\t//  e.g: GET 'var_name' FROM 'var var_name'", 
    "\t\t\t\t\t\t\t\"type\"\t: typeof variable_split[1]!= 'undefined' ? getValueDataType(variable_split[1])\t: 'void',\t//'[[%tabstop:type]]',", 
    "\t\t\t\t\t\t\t\"value\"\t: typeof variable_split[1]!= 'undefined' ? variable_split[1].trim()\t: 'value',\t//'[[%tabstop:value]]'", 
    "\t\t\t\t\t\t});", 
    "\t\t\t\t\t}", 
    "\t\t\t\t}", 
    "\t\t\t\treturn variables;", 
    "\t\t\t};", 
    "", 
    "\t\t\tvar match_params\t= /\\(\\s*(\\S.*)\\s*\\)/gi.exec(this.input_string); // get parameters chain from brackets", 
    "\t\t\tLogger.info(this.input_string,'PraseCodeTag.input_string');", 
    "\t\t\tLogger.info(match_params,'PraseCodeTag.match_params');", 
    "", 
    "\t\t\tif (match_params){", 
    "", 
    "\t\t\t\tvariable_pairs = match_params.pop().replace(/,(?:\\s*(\\w+)\\s*=)/gi, '|,|$1=').split('|,|');", 
    "\t\t\t\tvar variable_pairs_splitted\t= _splitVariablePairs(variable_pairs);", 
    "", 
    "\t\t\t\treturn variable_pairs_splitted.map(function(var_data){", 
    "\t\t\t\t\treturn [ '@param', var_data.type, var_data.name, var_data.value ];", 
    "\t\t\t\t});", 
    "\t\t\t}", 
    "\t\t};", 
    "", 
    "\t\t/** _Parse_Variable", 
    "\t\t */", 
    "\t\tthis.parse_var = function()", 
    "\t\t{", 
    "\t\t\tvar\tmatch_variable\t= this.input_string.matchAll_v2(/var\\s*(\\S+)\\s*=/gi, true);", 
    "", 
    "\t\t\tif (match_variable)", 
    "\t\t\t\treturn ['@var', 'void', match_variable[1][1]];", 
    "\t\t};", 
    "", 
    "\t\t/** _Parse_return", 
    "\t\t */", 
    "\t\tthis.parse_return = function()", 
    "\t\t{", 
    "", 
    "\t\t\tvar match_return\t= /[\\s]return\\s+(.*)/gi.exec(this.input_string);", 
    "\t\t\t//Logger.info(match_return, 'match_return');", 
    "\t\t\tif(!match_return) return;", 
    "", 
    "\t\t\t/* IF value of return is defined */", 
    "\t\t\tvar data_type\t= typeof match_return[1] ? getValueDataType(match_return.pop()) : 'void';", 
    "\t\t\treturn ['@return', data_type, 'description new' ];", 
    "\t\t};", 
    "", 
    "\t\t/*\t-------------------------------------------------------------------------------------------------------------\t*/", 
    "\t\t/*\tGET MAIN PROPERTIES\t*/", 
    "\t\t/*\t-------------------------------------------------------------------------------------------------------------\t*/", 
    "", 
    "\t\t/* find datatype of given value.", 
    "\t\t *", 
    "\t\t * Example value='foo' >>> return 'string'\t| value='['A','B']' >>> return 'array'\t| value='true' >>> return 'boolean'", 
    "\t\t *", 
    "\t\t * @param\tstring\tvalue\tstringified variable value", 
    "\t\t * @return string datatypes 'boolean|null|array|object|float|integer|string'", 
    "\t\t */", 
    "\t\tvar getValueDataType = function(value)", 
    "\t\t{", 
    "\t\t\t//alert( value );", 
    "\t\t\tvar dataTypeMatches = {", 
    "\t\t\t\t\"boolean\":\t'true|false',", 
    "\t\t\t\t\"null\":\t'null',", 
    "\t\t\t\t\"array\":\t'[\\\\[\\\\]]',", 
    "\t\t\t\t\"object\":\t'[\\{\\}]',", 
    "\t\t\t\t\"float\":\t'[\\\\d]+\\\\.[\\\\d]+',", 
    "\t\t\t\t\"integer\":\t'\\\\d+',", 
    "\t\t\t\t\"string\":\t'[\\'\"].*[\\'\"]',", 
    "\t\t\t};", 
    "", 
    "\t\t\tfor ( var key in dataTypeMatches ) {", 
    "\t\t\t\tif ( value.trim().match(dataTypeMatches[key]) !== null )", 
    "\t\t\t\t\treturn key;", 
    "\t\t\t}", 
    "\t\t\treturn 'void';", 
    "\t\t};", 
    "", 
    "", 
    "\t}", 
    "\t/*--------   PROTOTYPE METHODS  -------------------------------------------------------------------------------------------------*/", 
    "", 
    "\t/*--------   RETURN THIS CLASS   -------------------------------------------------------------------------------------------------*/", 
    "", 
    "\treturn PraseCodeTag;", 
    "})();", 
    "", 
    "", 
    "", 
    "", 
    "/* ------------ TEST -------------------------------------------------------------------------------------------------- */", 
    "", 
    "///** Properties test for object PraseCodeTag", 
    "// *", 
    "// */", 
    "//ko.extensions.parseCodeTest = (function() {", 
    "//\tvar properties = ['test_prop'];", 
    "//\tvar Objects = {", 
    "//\t\ttest_name:\tnew ko.extensions.parseTag(),", 
    "//\t};", 
    "//\tko.extensions.TestObejctProperties(Objects,properties);", 
    "//});", 
    "///* RUN TEST */", 
    "//ko.extensions.parseCodeTest();", 
    "", 
    "", 
    "var Logger\t= new ko.extensions.Logger_v3('PraseCodeTag.js').clear();", 
    "", 
    "var input_function =\t'\tfunction TestPhpDoc (param1=\"fooString\", param2=true,array=[1,2,3] ){'+", 
    "\t'\\n\t\tvar string\t= require(\"ko/console\").warn(Array(5).join(param1+\"-\"));'+", 
    "\t'\\n\t\t'+", 
    "\t'\\n\t\treturn string;'+", 
    "\t'\\n\t}';", 
    "", 
    "var PraseCodeTag\t= new ko.extensions.parseTag();", 
    "", 
    "var parsed_param = PraseCodeTag.parse('param', input_function);", 
    "Logger.info(parsed_param, 'parsed_param');", 
    "", 
    "", 
    "", 
    "", 
    ""
  ], 
  "version": "1.0.12", 
  "async": 1, 
  "type": "macro", 
  "icon": "chrome://fugue/skin/icons/tick.png"
}