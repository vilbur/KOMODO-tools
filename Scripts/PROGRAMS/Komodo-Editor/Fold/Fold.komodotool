{
  "keyboard_shortcut": "", 
  "name": "Fold", 
  "language": "JavaScript", 
  "trigger_enabled": 0, 
  "rank": 100, 
  "trigger": "trigger_startup", 
  "value": [
    "/* TODO: write foldin script", 
    "*/", 
    "", 
    "ko.extensions.Fold = (function() {", 
    " ", 
    "\tfunction Fold(toggle, level_input=null){", 
    "", 
    "\t\t//var rx_comment_block\t= '(\\/\\*(.|[\\r\\n])+?(?:\\*\\/))';\t\t // SINGLE AND MULTILINE", 
    "\t\tvar rx_comment_block \t= '(\\/\\*(.?(?!\\*\\/))+[\\r\\n](.|[\\r\\n])*?(?:\\*\\/))';\t\t // block comment MULTILINE\t\t", 
    "\t\t", 
    "\t\tthis.regex_levels_all\t= {", 
    "\t\t", 
    "\t\t\t/* LANGUAGES */", 
    "\t\t\t\"global\":{", 
    "\t\t\t\t/* LEVELS */", 
    "\t\t\t\t\"comment\":\trx_comment_block,", 
    "\t\t\t},", 
    "\t\t\t", 
    "\t\t\t\"JavaScript\":{", 
    "\t\t\t\t/* LEVELS */", 
    "\t\t\t\t//'\\S+\\.(prototype\\.\\S+.*[\\r\\n\\s]*?{)|(function\\s+\\S+.*[\\r\\n]?{)|/\\*(?:[^*]|(?:\\*+[^*/]))*\\*+/',", 
    "\t\t\t\t//'\\S+\\.(prototype\\.\\S+.*[\\r\\n\\s]*?{)|(function\\s+\\S+.*[\\r\\n]?{)',", 
    "\t\t\t\t\"level_0\" :[", 
    "\t\t\t\t\trx_comment_block,\t// Comment block on closing", 
    "\t\t\t\t],", 
    "\t\t\t\t\"level_1\" :[", 
    "\t\t\t\t\t'\\S+\\.(prototype\\.\\S+.*[\\r\\n\\s]*?{)',\t// [this.]FooClass.prototype.function(){", 
    "\t\t\t\t\t'(function\\s+\\S+.*[\\r\\n\\s]*?{)',\t// function fooClassic()", 
    "\t\t\t\t\t'((this\\.)\\S+\\s*=\\s*\\(*function.*[\\r\\n\\s]*?{)',\t// this.fooFunction = function() ", 
    "\t\t\t\t],", 
    "\t\t\t\t\"level_2\" :[", 
    "\t\t\t\t\t'(\\S+\\s*=\\s*\\(function.*[\\r\\n\\s]*?{)',\t// ClassDefinition = function(){\t", 
    "\t\t\t\t\t'(\\(function.*[\\r\\n\\s]*?{)',\t// (function(){\t// function definition object", 
    "\t\t\t\t\t'(if.*[\\r\\n\\s]*?{)',\t// (function(){\t// function definition object", 
    "\t\t\t\t\t", 
    "\t\t\t\t]", 
    "\t\t\t", 
    "\t\t\t\t//'/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+/',\t// multi line comment e.g: /* foo comment */", 
    "\t\t\t},", 
    "\t\t\t\"Autohotkey\":{", 
    "\t\t\t\t/* LEVELS */\t\t\t\t\t\t\t\t", 
    "\t\t\t\t\"level_0\"\t:rx_comment_block,\t// Comment block on closing", 
    "\t\t\t\t\"level_1\" :'(\\S+\\s*?\\([^\\)]*?\\)\\s*?\\{)'", 
    "\t\t\t}", 
    "\t\t};", 
    "\t\t", 
    "\t\tthis.regex_levels\t= [];", 
    "\t\tthis.fold_state\t= [];\t\t\t\t", 
    "\t\tthis.matches_data\t= {};", 
    "\t\t", 
    "\t\tkoDoc\t= ko.views.manager.currentView.koDoc;", 
    "\t\tscimoz\t= ko.views.manager.currentView.scimoz;", 
    "\t\tthis.lang\t= ko.views.manager.currentView.languageObj.name;", 
    "\t\tthis.anchor\t= scimoz.anchor;", 
    "\t\tthis.currentPos\t= scimoz.currentPos; \t\t", 
    "\t\tthis.filepath\t= ko.views.manager.currentView.koDoc.file.path;", 
    "\t\tthis.filepath\t= ko.views.manager.currentView.koDoc.file.path.split(/(\\|\\/)/g).pop();\t\t", 
    "", 
    "\t\tthis.toggle\t= toggle;", 
    "\t\tthis.level_input\t= level_input;", 
    "\t\tthis.selText\t= scimoz.selText;", 
    "\t\tthis.buffer\t= koDoc.buffer;\t\t", 
    "\t\tthis.content\t= this.selText!=='' ? this.selText : this.buffer;", 
    "\t\t", 
    "\t\tthis.getFoldState();", 
    "\t\tthis.getRegexLevelsForLang();", 
    "\t\tthis.level\t= level_input ? level_input : this._getLevel(); // this.levels must be set AFTER this.regex_levels", 
    "\t\tthis.getMatchesData();", 
    "\t\tthis.foldLevels();\t\t", 
    "\t\t//this.restorePosition();", 
    "\t\t", 
    "\t\t//alert('regex_levels=\\n'+JSON.stringify( this.regex_levels, null, 4));", 
    "\t\t//alert('matches_data=\\n'+JSON.stringify( this.matches_data, null, 4));", 
    "\t\t//alert('fold_state=\\n'+JSON.stringify( this.fold_state, null, 4));", 
    "\t}", 
    "\t/*\t-------------------------------------------------------------------------------------------------------------\t*/", 
    "\t/*\tGET DATA\t*/", 
    "\t/*\t-------------------------------------------------------------------------------------------------------------\t*/", 
    "\t/*", 
    "\t */", 
    "\tFold.prototype.getRegexLevelsForLang = function(){", 
    "\t\tvar regex_lang\t= this.regex_levels_all[this.lang];", 
    "\t\t/* LOOP regexes per language */", 
    "\t\tfor(var r=0; r<Object.keys(regex_lang).length;r++){\t\t\t", 
    "\t\t    this._getRegexLevel( Object.keys(regex_lang)[r] );", 
    "\t\t}", 
    "\t};", 
    "\t/* get only matches which match to this.toggle mode //", 
    "\t*", 
    "\t* get only this.regex_levels_all.lang['*open*']\twhen this.toggle == 'open'", 
    "\t* get only this.regex_levels_all.lang['*close*']\twhen this.toggle == 'close'", 
    "\t* ", 
    "\t*/", 
    "\tFold.prototype._getRegexLevel = function(key){", 
    "\t\t", 
    "\t\t//if((this.toggle == 'open' && !key.match(/close/)) || (this.toggle == 'close' && !key.match(/open/))){", 
    "\t\t\tvar regex = this.regex_levels_all[this.lang][key];", 
    "\t\t\t//alert( 'regex=\\n'+JSON.stringify( regex, null, 2) );", 
    "\t\t\tif(typeof regex == 'object') regex = regex.join('|');\t\t\t", 
    "\t\t\tvar matches = this.content.match( new RegExp( regex, \"gi\"));", 
    "\t\t\t//alert( 'matches=\\n'+JSON.stringify( matches, null, 2) )\t\t\t ", 
    "\t\t\tif(matches) this.regex_levels.push( this.ArrayUnique( matches ));", 
    "\t\t", 
    "\t};", 
    "\t/*", 
    "\t */", 
    "\tFold.prototype.getMatchesData = function(){", 
    "\t\t", 
    "\t\tif(this.regex_levels)", 
    "\t\t\t/* Loop all levels */", 
    "\t\t\tfor(var l=0; l<this.regex_levels.length;l++){", 
    "\t\t\t\tif(typeof this.matches_data[l] == 'undefined' ) this.matches_data[l] = [];", 
    "\t\t\t\t/* Loop all regexes */\t\t\t\t", 
    "\t\t\t\tfor(var r=0; r<this.regex_levels[l].length;r++){", 
    "\t\t\t\t\tvar regex = this.regex_levels[l][r];", 
    "\t\t\t\t\tthis.matches_data[l][r] = this._getMatchObjects(regex, this._findLineIndexOfMatch( regex ));\t\t", 
    "\t\t\t\t}", 
    "\t\t\t}", 
    "\t};", 
    "\t/*", 
    "\t*/", 
    "\tFold.prototype._getMatchObjects = function(match, match_index){", 
    "\t\t", 
    "\t\t/* IF MULTIPLE MATCHES FOUND */", 
    "\t\tif( match_index && match_index[0].constructor === Array) {", 
    "\t\t\tvar match_objects = [];", 
    "\t\t\tfor(var s=0; s<match_index.length;s++){", 
    "\t\t\t\tmatch_objects.push(this._getMatchObjectValues(match, match_index[s]));", 
    "\t\t\t}", 
    "\t\t\treturn match_objects;", 
    "\t\t} else if( match_index )", 
    "\t\t", 
    "\t\treturn this._getMatchObjectValues(match, match_index);\t", 
    "\t};", 
    "\t/*", 
    "\t*/", 
    "\tFold.prototype._getMatchObjectValues = function(match, match_index){", 
    "\t\treturn {", 
    "\t\t\t\"match\"\t:match,", 
    "\t\t\t\"index\"\t:match_index[0],\t\t\t\t", 
    "\t\t\t\"fold\"\t:match_index[1],", 
    "\t\t\t\"state\"\t:this._getLineFoldState(match_index[1])", 
    "\t\t};", 
    "\t};", 
    "\t/*", 
    "\t */", 
    "\tFold.prototype.foldLevels = function(){", 
    "\t", 
    "\t\tfor (level=0; level<Object.keys(this.matches_data).length;level++){", 
    "\t\t\t", 
    "\t\t\tif ((level <= this.level && this.toggle == 'close') || (level >= this.level && this.toggle == 'open'))", 
    "\t\t\t\tthis._foldLevel(level);", 
    "\t\t\t\t", 
    "\t\t} ", 
    "\t};", 
    "\t/*", 
    "\t */", 
    "\tFold.prototype._foldLevel = function(level){", 
    "\t\t//alert( 'this.matches_data=\\n'+JSON.stringify( this.matches_data, null, 2) )", 
    "\t\t", 
    "\t\tfor(var i=0; i<Object.keys( this.matches_data[level]).length;i++){", 
    "\t\t\tvar line =  this.matches_data[level][i];", 
    "\t\t\tthis._collapseLine(line.index, line.state);", 
    "\t\t}", 
    "\t};", 
    "\t/* restore anchor and cursor position after folding", 
    "\t*/", 
    "\tFold.prototype.restorePosition = function(){", 
    "\t\tscimoz.anchor\t= this.anchor;", 
    "\t\tscimoz.currentPos\t= this.currentPos;", 
    "\t\tscimoz.scrollCaret();", 
    "\t};", 
    "\t/*", 
    "\t*/", 
    "\tFold.prototype.getFoldState = function(){", 
    "\t\t", 
    "\t\tfor (line_index=0; line_index< scimoz.lineCount-1 ;line_index++){", 
    "\t\t\tvar line_fold_state\t= this._getLineFoldState(line_index);", 
    "\t\t\t", 
    "\t\t\tif(line_fold_state=='close') {", 
    "\t\t\t\tscimoz.gotoLine(line_index);", 
    "\t\t\t\tthis.fold_state.push(line_index);", 
    "\t\t\t\tko.commands.doCommand('cmd_foldCollapse');", 
    "\t\t\t}", 
    "\t\t}", 
    "\t\t", 
    "\t\tthis.restoreFoldState();", 
    "\t};", 
    "\t/*", 
    "\t*/", 
    "\tFold.prototype._getLevel = function(){", 
    "\t\t", 
    "\t\tthis._defineFoldToogleLevels();", 
    "\t\tvar max_level_curent_file = this.regex_levels.length -1;", 
    "\t\t", 
    "\t\t/* ADD +1 TO LEVEL IF CLOSE */", 
    "\t\tif(this.toggle==\"close\")", 
    "\t\t\treturn (FoldToogleLevels[this.filepath] < max_level_curent_file ) ? FoldToogleLevels[this.filepath]++ : FoldToogleLevels[this.filepath];", 
    "", 
    "\t\t/* REMOVE -1 FROM LEVEL IF OPEN */\t\t", 
    "\t\telse if(this.toggle==\"open\" )", 
    "\t\t\treturn ( FoldToogleLevels[this.filepath] > 0 ) ? FoldToogleLevels[this.filepath]-- : 0 ;", 
    "\t", 
    "\t};", 
    "\t/* @variable\tFoldToogleLevels global variable keeps state of folding level per file", 
    "\t* @example\tFoldToogleLevels{\"Fold.js\":1} // file \"Fold.js\" is folded in level 1", 
    "\t*/", 
    "\tFold.prototype._defineFoldToogleLevels = function(){", 
    "\t\tif (typeof FoldToogleLevels\t== 'undefined')\tFoldToogleLevels = {};", 
    "\t\tif (typeof FoldToogleLevels[this.filepath]\t== 'undefined')\tFoldToogleLevels[this.filepath] = 0;", 
    "\t};", 
    "\t/*", 
    "\t*/", 
    "\tFold.prototype._collapseLine = function(line_index,state){", 
    "\t\tscimoz.gotoLine(line_index);", 
    "\t\tif( (state=='open' && this.toggle == 'close')||(state=='close' && this.toggle == 'open') ){", 
    "\t\t\tko.commands.doCommand('cmd_foldCollapse');", 
    "\t\t}", 
    "\t};", 
    "\t/*", 
    "\t\tCheck if fold on line is open oor closed", 
    "\t\t@return true if Expanded (fold is open) OR false if closed", 
    "\t*/", 
    "\tFold.prototype._getLineFoldState = function(line_index){", 
    "\t\tscimoz.gotoLine(line_index);\t\t", 
    "\t\tscimoz.lineDown();", 
    "\t\tvar line_index_next = scimoz.lineFromPosition(scimoz.currentPos);", 
    "\t\tscimoz.lineUp();", 
    "\t", 
    "\t\treturn line_index_next -1 == line_index ? 'open' : 'close';", 
    "\t};", 
    "\t/* Find line index of multiline string in multiline string", 
    "\t* @param string substring\tstrinf to search", 
    "\t* ", 
    "\t* @return array|null\tif found return array [start_index, end_index], multiarray if mutiple matches found", 
    "\t* ", 
    "\t*\t@example", 
    "\t*\t\t_findLineIndexOfMatch(\"only one occurence\")\t [2,2]", 
    "\t*\t\t_findLineIndexOfMatch(\"two occurences\")\t [[2,2][7,7]]", 
    "\t*\t\t_findLineIndexOfMatch(\"two occurences\\n on two lines\")\t [[2,3][7,8]]", 
    "\t*/", 
    "\tFold.prototype._findLineIndexOfMatch = function(substring){", 
    "\t\tvar line = 0, matchedChars = 0;", 
    "\t\t", 
    "\t\tvar matches = [];", 
    "\t\tvar lines_count = substring.split(/[\\n]/).length - 1;", 
    "\t\t", 
    "\t\tfor (var i = 0; i < this.buffer.length; i++) {", 
    "\t\t\t//this.buffer[i] === substring[matchedChars] ? matchedChars++ : matchedChars = 0;", 
    "\t\t\tif (this.buffer[i] === substring[matchedChars] ? matchedChars++ : matchedChars = 0){", 
    "\t\t\t\t", 
    "\t\t\t\tif (matchedChars === substring.length){", 
    "\t\t\t\t\tif(lines_count==1)", 
    "\t\t\t\t\t\tmatches.push( [line,line] );", 
    "\t\t\t\t\telse", 
    "\t\t\t\t\t\tmatches.push( [line -lines_count ,line] );", 
    "\t\t\t\t}", 
    "\t\t\t}", 
    "\t\t", 
    "\t\t\tif (this.buffer[i] === '\\n')", 
    "\t\t\t\tline++;", 
    "\t\t\t", 
    "\t\t}", 
    "\t\t", 
    "\t\tif(matches.length == 1)", 
    "\t\t\tmatches\t= matches[0];", 
    "\t\t\t", 
    "\t\treturn  matches.length > 0 ? matches : null;", 
    "\t};", 
    "\t/*", 
    "\t*/", 
    "\tFold.prototype.ArrayUnique = function(Array) {", 
    "\t\tvar unique = [];", 
    "\t\tfor (var i = 0; i < Array.length; i++) {", 
    "\t\t\tif (unique.indexOf(Array[i]) == -1) {", 
    "\t\t\t\tunique.push(Array[i]);", 
    "\t\t\t}", 
    "\t\t}", 
    "\t\treturn unique;", 
    "\t}; ", 
    "\t/* ", 
    "\t*/", 
    "\tFold.prototype.restoreFoldState = function(){", 
    "\t\tfor (i=this.fold_state.length-1; i>=0 ;i--){", 
    "\t\t\tscimoz.gotoLine(this.fold_state[i]);", 
    "\t\t\tko.commands.doCommand('cmd_foldCollapse');", 
    "\t\t}\t\t", 
    "\t};", 
    "\t", 
    "\t", 
    "\treturn Fold;", 
    "})();"
  ], 
  "version": "1.0.12", 
  "async": 1, 
  "type": "macro", 
  "icon": "chrome://fugue/skin/icons/plus.png"
}